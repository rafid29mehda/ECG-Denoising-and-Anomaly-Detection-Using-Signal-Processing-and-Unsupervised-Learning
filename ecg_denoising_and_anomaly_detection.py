# -*- coding: utf-8 -*-
"""ECG Denoising and Anomaly Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J7sfBHGbhzVqGegXdiHVm6c7JMnrhMgf
"""

# Step 1: Install dependencies
!pip install wfdb
!pip install neurokit2
!pip install pywt
import wfdb
import numpy as np
import pandas as pd
import neurokit2 as nk
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import IsolationForest
import matplotlib.pyplot as plt
import pywt
import os

# Step 2: Generate synthetic data
def load_synthetic_data(duration=600, sampling_rate=360, anomaly_rate=0.05):
    # Generate clean ECG signal
    ecg_clean = nk.ecg_simulate(duration=duration, sampling_rate=sampling_rate, heart_rate=60, noise=0.05, random_state=42)

    # Add synthetic anomalies (e.g., irregular peaks)
    np.random.seed(42)
    anomaly_indices = np.random.choice(len(ecg_clean), size=int(len(ecg_clean) * anomaly_rate), replace=False)
    ecg_signal = ecg_clean.copy()
    ecg_signal[anomaly_indices] += np.random.normal(0, 0.5, size=len(anomaly_indices))  # Add noise spikes

    # Generate binary anomaly labels (for evaluation, not used in training)
    labels = np.zeros(len(ecg_signal))
    labels[anomaly_indices] = 1

    print(f"ECG shape: {ecg_signal.shape}")
    print(f"Labels shape: {labels.shape}")
    print(f"Anomaly distribution: {pd.Series(labels).value_counts().to_dict()}")
    return ecg_signal, labels

ecg_signal, labels = load_synthetic_data()

# Step 3: Preprocess ECG
def preprocess_ecg(ecg_signal, sampling_rate=360, window_size=3600):
    # Remove baseline wander using polynomial fitting
    t = np.arange(len(ecg_signal))
    poly_coeffs = np.polyfit(t, ecg_signal, deg=5)
    baseline = np.polyval(poly_coeffs, t)
    ecg_no_baseline = ecg_signal - baseline

    # Segment into windows
    segments = []
    for i in range(0, len(ecg_signal) - window_size, window_size // 2):
        segment = ecg_no_baseline[i:i + window_size]
        segments.append(segment)
    segments = np.array(segments)

    print(f"Number of segments: {len(segments)}")
    print(f"Segment shape: {segments.shape}")
    return segments, ecg_no_baseline

segments, ecg_no_baseline = preprocess_ecg(ecg_signal)

# Step 4: Denoise ECG
def denoise_ecg(segments, wavelet='db6', level=4):
    # Apply wavelet denoising to each segment
    denoised_segments = []
    for segment in segments:
        coeffs = pywt.wavedec(segment, wavelet=wavelet, level=level)
        # Threshold high-frequency coefficients
        threshold = np.std(coeffs[-1]) * np.sqrt(2 * np.log(len(segment)))
        coeffs[1:] = [pywt.threshold(c, threshold, mode='soft') for c in coeffs[1:]]
        denoised_segment = pywt.waverec(coeffs, wavelet=wavelet)
        # Ensure output length matches input
        denoised_segment = denoised_segment[:len(segment)]
        denoised_segments.append(denoised_segment)
    denoised_segments = np.array(denoised_segments)

    print(f"Denoised segments shape: {denoised_segments.shape}")
    return denoised_segments

denoised_segments = denoise_ecg(segments)

# Step 5: Detect anomalies
def detect_anomalies(denoised_segments, contamination=0.05):
    # Extract simple features (e.g., mean, std, max, min) for each segment
    features = np.column_stack([
        np.mean(denoised_segments, axis=1),
        np.std(denoised_segments, axis=1),
        np.max(denoised_segments, axis=1),
        np.min(denoised_segments, axis=1)
    ])

    # Normalize features
    scaler = StandardScaler()
    features = scaler.fit_transform(features)

    # Train Isolation Forest
    iso_forest = IsolationForest(contamination=contamination, random_state=42)
    anomaly_scores = iso_forest.fit_predict(features)

    # Convert predictions: -1 (anomaly) to 1, 1 (normal) to 0
    anomaly_labels = np.where(anomaly_scores == -1, 1, 0)

    print(f"Anomaly distribution: {np.bincount(anomaly_labels)}")
    return anomaly_labels, features

anomaly_labels, features = detect_anomalies(denoised_segments)

# Step 6: Visualize and save results
def visualize_and_save(ecg_no_baseline, anomaly_labels, features, segments):
    # Reconstruct full signal with anomaly flags
    window_size = segments.shape[1]
    anomaly_signal = np.zeros(len(ecg_no_baseline))
    for i, (start, label) in enumerate(zip(range(0, len(ecg_no_baseline) - window_size, window_size // 2), anomaly_labels)):
        if label == 1:
            anomaly_signal[start:start + window_size] = 1

    # Plot ECG with anomalies
    plt.figure(figsize=(15, 5))
    plt.plot(ecg_no_baseline, label='Denoised ECG', alpha=0.7)
    anomaly_indices = np.where(anomaly_signal == 1)[0]
    plt.scatter(anomaly_indices, ecg_no_baseline[anomaly_indices], c='red', label='Detected Anomalies', s=50)
    plt.title('ECG Signal with Detected Anomalies')
    plt.xlabel('Sample')
    plt.ylabel('Amplitude')
    plt.legend()
    plt.savefig('anomaly_plot.png')
    plt.show()

    # Save anomaly scores
    os.makedirs('results', exist_ok=True)
    with open('anomaly_scores.txt', 'w') as f:
        f.write("Anomaly Labels (1: Anomaly, 0: Normal):\n")
        f.write(np.array2string(anomaly_labels))

    # Download results in Colab
    from google.colab import files
    files.download('anomaly_plot.png')
    files.download('anomaly_scores.txt')

visualize_and_save(ecg_no_baseline, anomaly_labels, features, segments)